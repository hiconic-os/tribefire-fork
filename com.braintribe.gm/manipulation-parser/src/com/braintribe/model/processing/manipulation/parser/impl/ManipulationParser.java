// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ============================================================================
package com.braintribe.model.processing.manipulation.parser.impl;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonTokenFactory;
import org.antlr.v4.runtime.DiagnosticErrorListener;
import org.antlr.v4.runtime.UnbufferedCharStream;
import org.antlr.v4.runtime.UnbufferedTokenStream;
import org.antlr.v4.runtime.atn.PredictionMode;

import com.braintribe.model.generic.manipulation.AtomicManipulation;
import com.braintribe.model.generic.manipulation.Manipulation;
import com.braintribe.model.generic.manipulation.VoidManipulation;
import com.braintribe.model.generic.manipulation.util.ManipulationBuilder;
import com.braintribe.model.generic.tracking.ManipulationCollector;
import com.braintribe.model.generic.tracking.StandardManipulationCollector;
import com.braintribe.model.processing.manipulation.parser.api.GmmlParserConfiguration;
import com.braintribe.model.processing.manipulation.parser.api.GmmlParserException;
import com.braintribe.model.processing.manipulation.parser.api.ParseResponse;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlLexer;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParserListener;
import com.braintribe.model.processing.manipulation.parser.impl.listener.GmmlManipulationParserListener;
import com.braintribe.model.processing.manipulation.parser.impl.listener.HomeopathyDetectingParserListener;

public class ManipulationParser {

	public static Manipulation parse(String text) {
		StringReader reader = new StringReader(text);
		return parse(reader);
	}

	public static Manipulation parse(InputStream in, String charset) throws IOException {
		Reader reader = new InputStreamReader(in, charset);
		return parse(reader);
	}

	public static Manipulation parse(InputStream in, String charset, GmmlParserConfiguration config) throws IOException {
		Reader reader = new InputStreamReader(in, charset);
		return parse(reader, config);
	}

	public static Manipulation parse(Reader reader) {
		return parse(reader, Gmml.configuration());
	}

	public static Manipulation parse(Reader reader, GmmlParserConfiguration config) {
		ManipulationCollector manipulationCollector = new StandardManipulationCollector();

		parse(reader, manipulationCollector::noticeManipulation, config);

		List<Manipulation> manipulations = manipulationCollector.getManipulations();

		switch (manipulations.size()) {
			case 0:
				return VoidManipulation.T.create();
			case 1:
				return manipulations.get(0);
			default:
				return ManipulationBuilder.compound(manipulations);
		}
	}

	public static ParseResponse parse(Reader reader, Consumer<? super AtomicManipulation> manipulationConsumer, GmmlParserConfiguration config) {
		GmmlManipulationParserListener listener = new GmmlManipulationParserListener(config);
		listener.setManipulationConsumer(manipulationConsumer);

		parse(reader, config, listener);

		ParseResponse result = new ParseResponse();
		result.variables = listener.getVariables();
		result.lastAssignment = null;

		return result;
	}

	public static Set<String> findHomeopathicVariables(Reader reader, GmmlParserConfiguration config) {
		HomeopathyDetectingParserListener listener = new HomeopathyDetectingParserListener();
		parse(reader, config, listener);
		return listener.homeopathincVariables();
	}
	
	/* package */ static void parse(Reader reader, GmmlParserConfiguration config, GmmlParserListener listener) {
		GmmlSaneParser parser = null;

		try {
			parser = newParser(reader, config);
			parser.addParseListener(listener);

			if (config.parseSingleBlock())
				parser.block();
			else
				parser.blockSequence();

		} catch (Exception e) {
			if (parser != null)
				parser.throwErrorOrRuntimeExceptionIfYouAreAwareOfOne();

			// Some exception happened without the parser being aware of it
			throw new GmmlParserException("Error while parsing manipulations", e);
		}
	}

	public static GmmlSaneParser newParser(Reader reader, GmmlParserConfiguration config) {
		GmmlSaneParser parser = config.bufferEntireInput() ? newBufferedParserFor(reader) : newUnbufferedParserFor(reader);

		parser.setBuildParseTree(false);
		parser.addErrorListener(new DiagnosticErrorListener()); // To detect ambiguity
		parser.getInterpreter().setPredictionMode(PredictionMode.LL); // SLL once the grammar is changed and works
		
		return parser;
	}
	
	private static GmmlSaneParser newBufferedParserFor(Reader reader) {
		CharStream charStream = newANTLRInputStream(reader);

		GmmlLexer lexer = new GmmlLexer(charStream);
		lexer.removeErrorListeners();

		return new GmmlSaneParser(new UnbufferedTokenStream<>(lexer), charStream);
	}

	private static ANTLRInputStream newANTLRInputStream(Reader reader) {
		try {
			return new ANTLRInputStream(reader);
		
		} catch (IOException e) {
			throw new RuntimeException("Error while createing ANTLRInputStream", e);
		}
	}

	private static GmmlSaneParser newUnbufferedParserFor(Reader reader) {
		UnbufferedCharStream charStream = new UnbufferedCharStream(reader);

		GmmlLexer lexer = new GmmlLexer(charStream);
		lexer.removeErrorListeners();
		lexer.setTokenFactory(new CommonTokenFactory(true));

		return new GmmlUnbufferedSaneParser(new UnbufferedTokenStream<>(lexer), charStream);
	}
}
